<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Daniel Tobias - expository</title><link href="https://uberyb.github.io/" rel="alternate"></link><link href="https://uberyb.github.io/feeds/expository.atom.xml" rel="self"></link><id>https://uberyb.github.io/</id><updated>2023-02-01T18:43:08-08:00</updated><entry><title>Some encrypted page</title><link href="https://uberyb.github.io/some-encrypted-page.html" rel="alternate"></link><published>2023-02-01T18:43:08-08:00</published><updated>2023-02-01T18:43:08-08:00</updated><author><name>Daniel Tobias</name></author><id>tag:uberyb.github.io,2023-02-01:/some-encrypted-page.html</id><summary type="html">&lt;div id="pec-encrypted-content" style="display:none"&gt;ZKIryObJ5wB48ByI5x1+4Q==;5t+X5DyR4zqLqq/ypQ1PMfq0ThV/xbsnweLZ6aCy+jU=;^&lt;/div&gt;
&lt;div id="pec-decrypted-content"&gt;
    &lt;h4&gt;&lt;i&gt;&lt;/i&gt;&lt;/h4&gt;
&lt;/div&gt;

&lt;form id="pec-decrypt-form"&gt;
    &lt;label for="pec-content-password"&gt;Password&lt;/label&gt;
    &lt;input type="password" id="pec-content-password" placeholder="Password" /&gt;
    &lt;button type="button" id="pec-decrypt-content"&gt;Decrypt&lt;/button&gt;
&lt;/form&gt;


&lt;script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/components/core.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/components/enc-base64.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/components/cipher-core.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/components/pad-nopadding.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/components/md5.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/components/aes.js"&gt;&lt;/script&gt;


&lt;script type="text/javascript"&gt;
    (function () {
        var strip_padding = function (padded_content, padding_char) {
            /*
             * Strips the padding character from decrypted content.
             */
            for (var i = padded_content.length; i &gt; 0; i--) {
                if (padded_content[i - 1] !== padding_char) {
                    return padded_content.slice(0, i);
                }
            }
        };

        var decrypt_content = function (password, iv_b64, ciphertext_b64, padding_char) {
            /*
             * Decrypts the content …&lt;/script&gt;</summary><content type="html">&lt;div id="pec-encrypted-content" style="display:none"&gt;ZKIryObJ5wB48ByI5x1+4Q==;5t+X5DyR4zqLqq/ypQ1PMfq0ThV/xbsnweLZ6aCy+jU=;^&lt;/div&gt;
&lt;div id="pec-decrypted-content"&gt;
    &lt;h4&gt;&lt;i&gt;&lt;/i&gt;&lt;/h4&gt;
&lt;/div&gt;

&lt;form id="pec-decrypt-form"&gt;
    &lt;label for="pec-content-password"&gt;Password&lt;/label&gt;
    &lt;input type="password" id="pec-content-password" placeholder="Password" /&gt;
    &lt;button type="button" id="pec-decrypt-content"&gt;Decrypt&lt;/button&gt;
&lt;/form&gt;


&lt;script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/components/core.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/components/enc-base64.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/components/cipher-core.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/components/pad-nopadding.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/components/md5.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/components/aes.js"&gt;&lt;/script&gt;


&lt;script type="text/javascript"&gt;
    (function () {
        var strip_padding = function (padded_content, padding_char) {
            /*
             * Strips the padding character from decrypted content.
             */
            for (var i = padded_content.length; i &gt; 0; i--) {
                if (padded_content[i - 1] !== padding_char) {
                    return padded_content.slice(0, i);
                }
            }
        };

        var decrypt_content = function (password, iv_b64, ciphertext_b64, padding_char) {
            /*
             * Decrypts the content from the ciphertext bundle.
             */
            var key = CryptoJS.MD5(password),
                iv = CryptoJS.enc.Base64.parse(iv_b64),
                ciphertext = CryptoJS.enc.Base64.parse(ciphertext_b64),
                bundle = {
                    key: key,
                    iv: iv,
                    ciphertext: ciphertext
                };

            var plaintext = CryptoJS.AES.decrypt(bundle, key, { iv: iv, padding: CryptoJS.pad.NoPadding });

            try {
                return strip_padding(plaintext.toString(CryptoJS.enc.Utf8), padding_char);
            }
            catch (err) {
                // encoding failed; wrong password
                return false;
            }
        };


        document.addEventListener('DOMContentLoaded', function () {
            var decrypt_btn = document.getElementById('pec-decrypt-content'),
                password_input = document.getElementById('pec-content-password'),
                encrypted_content = document.getElementById('pec-encrypted-content'),
                decrypted_content = document.getElementById('pec-decrypted-content'),
                decrypt_form = document.getElementById('pec-decrypt-form');

            var decrypt_document = function (event) {
                // grab the ciphertext bundle
                var parts = encrypted_content.innerHTML.split(';');

                // decrypt it
                var content = decrypt_content(
                    password_input.value,
                    parts[0],
                    parts[1],
                    parts[2]
                );

                if (content) {
                    // success; display the decrypted content
                    decrypted_content.innerHTML = content;
                    decrypt_form.parentNode.removeChild(decrypt_form);
                    encrypted_content.parentNode.removeChild(encrypted_content);

                    // any post processing on the decrypted content should be done here
                }
                else {
                    // ¯\_(ツ)_/¯
                    password_input.value = '';
                }
                event.preventDefault();
                return false;
            }
            
            decrypt_btn.addEventListener('click', decrypt_document);
            decrypt_form.addEventListener('submit', decrypt_document);
        });
    })();
&lt;/script&gt;</content><category term="expository"></category></entry><entry><title>Kauffman &amp; Jones polynomial of Hopf link</title><link href="https://uberyb.github.io/kauffman-jones-polynomial-of-hopf-link.html" rel="alternate"></link><published>2023-01-18T12:43:14-08:00</published><updated>2023-01-18T12:43:14-08:00</updated><author><name>Daniel Tobias</name></author><id>tag:uberyb.github.io,2023-01-18:/kauffman-jones-polynomial-of-hopf-link.html</id><summary type="html">&lt;p&gt;This exercise came out of a series of lectures given for the &lt;a href="https://uberyb.github.io/topological-quantum-field-theory.html"&gt;Topological QFTs&lt;/a&gt; reading group. Really the lectures began as a way to catch up on elementary knot theory so that the group could further understand the work of &lt;a href="https://math.berkeley.edu/~vfr/"&gt;Vaughan Jones&lt;/a&gt;. This post is not meant to be tremendously …&lt;/p&gt;</summary><content type="html">&lt;p&gt;This exercise came out of a series of lectures given for the &lt;a href="https://uberyb.github.io/topological-quantum-field-theory.html"&gt;Topological QFTs&lt;/a&gt; reading group. Really the lectures began as a way to catch up on elementary knot theory so that the group could further understand the work of &lt;a href="https://math.berkeley.edu/~vfr/"&gt;Vaughan Jones&lt;/a&gt;. This post is not meant to be tremendously theoretical, but meant to serve as a gentle reminder about how one does these sorts of computations.  &lt;/p&gt;
&lt;p&gt;&lt;u&gt;Define.&lt;/u&gt; A knot is a closed curve seen as a subset $K \subset S^3$ which
should be interpreted as $\mathbb{R}$ plus a point at infinity.  &lt;/p&gt;
&lt;p&gt;There are reasons for why the point at infinity is useful (although it is not
relevant to the current task) and I believe containing the knot in $S^3$ is done
so that we can fit the whole knot in a compact space. There are some operations
on knots, but all we need here is to understand that knots can be &lt;em&gt;linked&lt;/em&gt;. A
link $L$ is a collection of non-intersecting knots that are "linked" together. A
good example of this is the Borromean link  &lt;/p&gt;
&lt;p&gt;&lt;img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/54/Borromean_Rings_Illusion_%28transparent%29.png/1024px-Borromean_Rings_Illusion_%28transparent%29.png" alt="Borromean Rings" width="200" /&gt;&lt;/p&gt;
&lt;p&gt;Each ring here (which is really just a circle) is called an "unknot". Observe
that the removal of any unknot from the picture would totally undo the link.  &lt;/p&gt;
&lt;p&gt;&lt;img alt="Hopf link" src="https://uberyb.github.io/images/knots/1.png"&gt;&lt;br&gt;
&lt;em&gt;Hopf link&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;A subtle detail of my drawing of the Hopf link: at the crossing there is
one completely solid line intersection a "broken" line. The broken line is to be
interpreted as the string which passes under the other string in the crossing.  &lt;/p&gt;
&lt;p&gt;One goal of knot theory is to classify knots. One way we can do this is to
capture a knot with algebraic information. In the case of the Jones polynomial
one must use a Laurent polynomial. First I'll start with a more general
polynomial for knots known as the &lt;a href="https://en.wikipedia.org/wiki/Bracket_polynomial"&gt;Kauffman bracket&lt;/a&gt; which is most easily defined inductively. For any link $L$ the Kauffman bracket $\langle L \rangle$ is&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$\langle L \rangle = 1$ if $L$ is the unknot.  &lt;/li&gt;
&lt;li&gt;$\langle \times \rangle = A \langle || \rangle + A^{-1} \langle = \rangle$  &lt;/li&gt;
&lt;li&gt;$\langle U \sqcup L = (-A^2 - A^{-2})\langle L \rangle$ (where $U$ is the
     unknot and $L$ is some link)  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Rule 2 will require further explanation. The symbols $\times$, $||$, and $=$ are
meant to be seen as physical string. $\times$ implies there is a crossing, $||$
implies the strings are vertical and parallel whereas $=$ implies the strings
are horizontal and parallel. The idea is to "smooth" or reduce knot crossings
into the sum of these two components. &lt;/p&gt;
&lt;p&gt;So we can decompose the Hopf link using a recursive approach in a sort of tree
structure such as:  &lt;/p&gt;
&lt;p&gt;&lt;img alt="Kauffman bracket of the Hopf link" src="https://uberyb.github.io/images/knots/2.png"&gt;  &lt;/p&gt;
&lt;p&gt;The diagram starts with the Hopf link and then we apply a single smoothing to a single crossing. I label the edges of my graph by the coefficient attached to the smoothing given by rule 2. The bottom middle two nodes of the tree are just unknots, and so their Kauffman brackets
are constant 1. Now the bottom left and bottom right nodes are regular isotopies of another (meaning one can be transformed to the other by &lt;a href="https://en.wikipedia.org/wiki/Reidemeister_move"&gt;Reidemeister move's&lt;/a&gt; of type II and III). All that remains is to compute the Kauffman bracket of the double unkot.  &lt;/p&gt;
&lt;p&gt;By rule (1) a single unknot $U$ has bracket 1. By rule 3 $\langle U \sqcup U \rangle = (-A^2 - A^{-2})\langle U \rangle = (-A^2 - A^{-2})$. Meaning if we sum our components we get $$A^2(-A^2-A^{-2})+1+1+A^{-2}(-A^2 -A^{-2}) = -A^4 - A^{-4}$$&lt;/p&gt;
&lt;p&gt;Something else you could do is start with a sum of all possible smoothings.
Suppose the unknot's polynomial is $-A^2 - A^{-2}$ then instead of a recursive
tree you could have a list of all possible smoothings (where we smooth all
crossings at the same time)  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://uberyb.github.io/images/knots/3.png"&gt;&lt;/p&gt;
&lt;p&gt;Notice the sum here is $(A^2 + A^{-2})(A^4 + A^{-4})$ which has an additional
factor on our answer from the recursive approach. Remembering that we "scaled"
the unknots polynomial, we can renormalize by dividing out $(-A^2 - A^{-2})$&lt;/p&gt;
&lt;p&gt;Now if $A^4 = t$ this is Jones polynomial of the Hopf link (in fact
orienting the link and multiplying the bracket by a factor $A^{-3wr(L)}$ will
get you to the Jones polynomial).&lt;/p&gt;
&lt;p&gt;A question that I spent some time thinking about is how to motivate $-A^2 - A^{-2}$ as the choice for the unknot's bracket. This expression is obviously not very random. For one, it has the nice property that $\langle \bigsqcup U_n \rangle = (-A^2 - A^{-2})^n$ where $U_n$ is a length $n$ sequence of unknots. It also happens to show up in the invariance of the Kauffman bracket under the Reidemeister type II move which Sanchayan Dutta recently &lt;a href="https://sanchayandutta.wordpress.com/2023/01/09/the-strange-third-rule-of-kauffmans-bracket/"&gt;wrote about&lt;/a&gt;. Namely, it is the constant $\delta$.&lt;/p&gt;</content><category term="expository"></category></entry><entry><title>Sample</title><link href="https://uberyb.github.io/sample.html" rel="alternate"></link><published>2022-09-21T19:19:25-07:00</published><updated>2022-09-21T19:19:25-07:00</updated><author><name>Daniel Tobias</name></author><id>tag:uberyb.github.io,2022-09-21:/sample.html</id><content type="html">&lt;p&gt;test&lt;/p&gt;
&lt;p&gt;$$\oint_{\gamma}f(z) dz = 0$$&lt;/p&gt;</content><category term="expository"></category></entry></feed>